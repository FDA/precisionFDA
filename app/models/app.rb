# == Schema Information
#
# Table name: apps
#
#  id            :integer          not null, primary key
#  dxid          :string
#  version       :string
#  revision      :integer
#  title         :string
#  readme        :text
#  user_id       :integer
#  scope         :string
#  spec          :text
#  internal      :text
#  created_at    :datetime         not null
#  updated_at    :datetime         not null
#  app_series_id :integer
#

class App < ActiveRecord::Base
  include Auditor
  include Permissions
  include InternalUid

  belongs_to :user
  belongs_to :app_series
  has_many :jobs
  has_many :notes, {through: :attachments}
  has_many :attachments, {as: :item, dependent: :destroy}

  has_and_belongs_to_many :assets, {join_table: 'apps_assets'}

  has_many :challenges

  store :spec, accessors: [ :input_spec, :output_spec, :internet_access, :instance_type ], coder: JSON
  store :internal, accessors: [ :ordered_assets, :packages, :code ], coder: JSON

  acts_as_commentable

  VALID_IO_CLASSES = ["file", "string", "boolean", "int", "float"]

  def to_param
    uid
  end

  # Scopes of files that can be used to run an app. This makes sense only for review spaces
  def space_scopes
    return [] unless in_space?
    return [] unless space_object.review?

    space_object.accessible_scopes
  end

  # Scopes that can be used to run an app. This makes sense only for review spaces
  def available_job_spaces(user)
    return [] unless in_space?
    return [] unless space_object.review?

    Space.joins(:space_memberships)
      .merge(SpaceMembership.where(user_id: user.id))
      .where(id: [space_object.id, space_object.confidential_spaces.pluck(:id)])
  end

  def can_run_in_space?(user, space_id)
    return false unless in_space?
    return false unless space_object.review?
    # TODO control disabled users!
    # member = space_object.space_memberships.active.where(user_id: user.id).first
    member = space_object.space_memberships.where(user_id: user.id).first
    return false unless member

    available_job_spaces(user).where(id: space_id).exists?
  end

  def name
    app_series.name
  end

  def klass
    "app"
  end

  def describe_fields
    ["title", "name", "version", "revision", "readme", "spec", "dxid"]
  end

  def versioned?
    version.present?
  end

  def publishable_by?(context, scope_to_publish_to = "public")
    # App series must be private, otherwise must match scope
    core_publishable_by?(context, scope_to_publish_to) && private? && (app_series.private? || (app_series.scope == scope_to_publish_to))
  end

  def accessible_by?(context)
    return true if super

    return false unless context.logged_in?
    return false unless context.review_space_admin?

    space_object.reviewer? || space_object.verification?
  end

  def to_docker(context_token)
    # Generate Dockerfile for app
    cmds = []
    cmds << "# Generated by precisionFDA exporter (v1.0.3) on #{Time.now.to_s}"
    cmds << "# The asset download links in this file are valid only for 24h."
    cmds << ""
    cmds << "# Exported app: #{name}, revision: #{revision}, authored by: #{user.username}"
    cmds << "# #{Rails.application.routes.url_helpers.app_url(self)}"
    cmds << ""
    cmds << "# For more information please consult the app export section in the precisionFDA docs"
    cmds << ""
    cmds << "# Start with Ubuntu 14.04 base image"
    cmds << "FROM ubuntu:14.04"
    cmds << ""

    apt_packages = [
      "aria2",
      "byobu",
      "cmake",
      "cpanminus",
      "curl",
      "dstat",
      "g++",
      "git",
      "htop",
      "libboost-all-dev",
      "libcurl4-openssl-dev",
      "libncurses5-dev",
      "make",
      "perl",
      "pypy",
      "python-dev",
      "python-pip",
      "r-base",
      "ruby1.9.3",
      "wget",
      "xz-utils"
    ]
    cmds << "# Install default precisionFDA Ubuntu packages"
    cmds << "RUN DEBIAN_FRONTEND=noninteractive apt-get update && apt-get install -y \\\n\t#{apt_packages.join(" \\\n\t")}"
    cmds << ""

    python_packages = [
      "requests==2.5.0",
      "futures==2.2.0",
      "setuptools==10.2"
    ]
    cmds << "# Install default precisionFDA python packages"
    cmds << "RUN pip install \\\n\t#{python_packages.join(" \\\n\t")}"
    cmds << ""

    cmds << "# Add DNAnexus repo to apt-get"
    cmds << "RUN /bin/bash -c \"echo 'deb http://dnanexus-apt-prod.s3.amazonaws.com/ubuntu trusty/amd64/' > /etc/apt/sources.list.d/dnanexus.list\""
    cmds << "RUN /bin/bash -c \"echo 'deb http://dnanexus-apt-prod.s3.amazonaws.com/ubuntu trusty/all/' >> /etc/apt/sources.list.d/dnanexus.list\""
    cmds << "RUN curl https://wiki.dnanexus.com/images/files/ubuntu-signing-key.gpg | apt-key add -"
    cmds << ""

    # Generate Docker command for installing apt-packages
    if packages.present?
      cmds << "# Install app-specific Ubuntu packages"
      cmds << "RUN DEBIAN_FRONTEND=noninteractive apt-get update && apt-get install -y \\\n\t#{packages.join(" \\\n\t")}"
    else
      cmds << "# Update apt-get"
      cmds << "RUN DEBIAN_FRONTEND=noninteractive apt-get update"
    end
    cmds << ""

    # Generate download URLs and Docker commands for each asset
    if assets.present?
      cmds << "# Download app assets"
      assets.sort_by { |asset| ordered_assets.find_index(asset.dxid) }.each do |asset|
        url = DNAnexusAPI.new(context_token).call(asset.dxid, "download", {filename: asset.name, project: asset.project, preauthenticated: true})["url"]
        tar_opts = asset.is_gzipped? ? 'xzf -' : 'xf -'
        cmds << "RUN curl #{url} | tar #{tar_opts} -C / --no-same-owner --no-same-permissions"
      end
      cmds << ""
    end

    cmds << "# Download helper executables"
    cmds << "RUN curl https://dl.dnanex.us/F/D/0K8P4zZvjq9vQ6qV0b6QqY1z2zvfZ0QKQP4gjBXp/emit-1.0.tar.gz | tar xzf - -C /usr/bin/ --no-same-owner --no-same-permissions"
    cmds << "RUN curl https://dl.dnanex.us/F/D/bByKQvv1F7BFP3xXPgYXZPZjkXj9V684VPz8gb7p/run-1.2.tar.gz | tar xzf - -C /usr/bin/ --no-same-owner --no-same-permissions"
    cmds << ""

    # Generate Docker command with embedded spec and script
    shell_friendly_spec = {spec: spec, assets: ordered_assets, packages: packages}.to_json.shellescape
    shell_friendly_code = {code: code}.to_json.shellescape

    cmds << "# Write app spec and code to root folder"
    cmds << "RUN " + ["/bin/bash", "-c", "echo -E #{shell_friendly_spec} > /spec.json"].to_json
    cmds << "RUN " + ["/bin/bash", "-c", "echo -E #{shell_friendly_code} | python -c 'import sys,json; print json.load(sys.stdin)[\"code\"]' > /script.sh"].to_json
    cmds << ""

    cmds << "# Create directory /work and set it to $HOME and CWD"
    cmds << "RUN mkdir -p /work"
    cmds << "ENV HOME=\"/work\""
    cmds << "WORKDIR /work"
    cmds << ""

    # Add entry point to container
    cmds << "# Set entry point to container"
    cmds << "ENTRYPOINT [\"/usr/bin/run\"]"
    cmds << ""

    cmds.join("\n")    # Join with newlines
  end
end
